// Package sqlfmt lets you do sprintf-like formatting of SQL strings while hopefully not
// blowing your kneecaps off.
//
// # Supported types:
// - int8, int16, int32, int64, int
// - uint8, uint16, uint32, uint64, uint
// - float32, float64
// - bool
// - []byte (as string)
// - string
// - time.Time
// - nil
//
//
// # Formatting rules:
//
// 	- nil => "NULL"
// 	- int, uint, float => as strconv.Itoa, strconv.FormatUint(n, 10), strconv.FormatFloat(f, 'f', -1, 64)
// 	- bool => TRUE or FALSE
// 	- []byte, string => ANSI SQL quoted strings (see below)
//
//
//
//
// # Table of Examples:
//
//   // generated by sqlfmt/cmd/genexample.go
// 	//   TYPE                   IN                                                                                                        OUT
// 	//   ---                    ---                                                                                                       ---
// 	//   string                 "string"                                                                                                  string
// 	//   string                 "string needing ' escape"                                                                                 'string needing \' escape'
// 	//   string                 "ðŸ”¥string containing UTF-8ðŸ”¥"                                                                               utf8mb4'ðŸ”¥string containing UTF-8ðŸ”¥'
// 	//   int                    -1                                                                                                        -1
// 	//   uint8                  0x1                                                                                                       1
// 	//   []uint8                []byte{0x73, 0x6f, 0x6d, 0x65, 0x20, 0x62, 0x79, 0x74, 0x65, 0x73}                                        some bytes
// 	//   []uint8                []byte{0x27, 0x65, 0x73, 0x63, 0x61, 0x70, 0x65, 0x27}                                                    '\'escape\''
// 	//   []uint8                []byte{0x27, 0x65, 0x73, 0x63, 0x61, 0x70, 0x65, 0x75, 0x74, 0x66, 0x38, 0xf0, 0x9f, 0x94, 0xa5, 0x27}    utf8mb4'\'escapeutf8ðŸ”¥\''
// 	//   main.NamedStruct       main.NamedStruct{}                                                                                        /*<bad type main.NamedStruct>*/
// 	//   float32                0                                                                                                         0
// 	//   float64                3.14                                                                                                      3.14
// 	//   struct { S string }    struct { S string }{S:"anonynous struct"}                                                                 /*<bad type struct { S string }>*/
// 	//   int8                   0                                                                                                         0
// 	//   int16                  0                                                                                                         0
// 	//   int32                  0                                                                                                         0
// 	//   int64                  0                                                                                                         0
// 	//   uint8                  0x0                                                                                                       0
// 	//   uint16                 0x0                                                                                                       0
// 	//   uint32                 0x0                                                                                                       0
// 	//   uint64                 0x0                                                                                                       0
// 	//   uintptr                0x0                                                                                                       0
// 	//   time.Time              time.Date(0, time.December, 31, 16, 7, 2, 0, time.Location("America/Los_Angeles"))                        0001-01-01T00:00:00Z
// 	//   time.Time              time.Date(1, time.January, 1, 0, 0, 0, 0, time.UTC)                                                       0001-01-01T00:00:00Z
//
// # ANSI SQL strings:
//
//   - ANSI SQL strings are enclosed in single quotes.
//   - The following code points must be escaped:
//
// # Table of escape codes:
/*
	// Hex     Char    Escape    Description
	// ---     ----    ------    -----------
	// 0x00    \x00    \0        NUL
	// 0x07    \a      \a        AUDIBLE BELL
	// 0x08    \b      \b        BACKSPACE
	// 0x09    \t      \t        HORIZONTAL TAB
	// 0x0A    \n      \n        LINE FEED / NEW LINE
	// 0x0B    \v      \v        VERTICAL TAB
	// 0x0C    \f      \f        FORM FEED
	// 0x0D    \r      \r        CARRIAGE RETURN
	// 0x1A    \x1a    \Z        SUBSTITUTE
	// 0x22    "       \"        DOUBLE QUOTE
	// 0x25    %       \%        PERCENT
	// 0x27    \'      \'        SINGLE QUOTE
	// 0x5C    \\      \\        BACKSLASH
	// 0x5F    _       \_        UNDERSCORE
*/
//
package sqlfmt

import (
	"fmt"
	"io"
	"os"
	"strings"
	"time"
)

type sqlquoter struct{ Val any }

// Println is a drop-in replacement for fmt.Println that formats []byte and string as sql-quoted strings when needed.
func FPrintln(w io.Writer, args ...any) (int, error) {
	return Fprintf(w, strings.Repeat("%v ", len(args)-1)+"%v\n", args...)
}

// Println is a drop-in replacement for fmt.Println that formats []byte and string as sql-quoted strings when needed.
func Println(args ...any) (int, error) { return FPrintln(os.Stdout, args...) }

// Print is a drop-in replacement for fmt.Print that formats []byte and string as sql-quoted strings when needed.
func Print(args ...any) (int, error) { return Fprint(os.Stdout, args...) }

// Fprint is a drop-in replacement for fmt.Fprint that formats []byte and string as sql-quoted strings when needed.
func Fprint(w io.Writer, args ...any) (int, error) {
	return Fprintf(w, strings.Repeat("%v ", len(args)-1)+"%v", args...)
}

// Fprintf is a drop-in replacement for fmt.Fprintf that accepts only the ordinary SQL types and formats []byte and string as sql-quoted strings when needed.
// This respects format specifiers where possible, but only support the ordinary %v verb.
// See the package documentation for details on the quoting.
func Fprintf(w io.Writer, format string, args ...any) (int, error) {
	// Replace all args with a QuoteFormatter and let it figure it out.
	for i := range args {
		args[i] = sqlquoter{args[i]}
	}
	return fmt.Fprintf(w, format, args...)
}

// Sprintf is a drop-in replacement for fmt.Sprintf that formats []byte and string as sql-quoted strings when needed.
// See the package documentation for details on the quoting.
func Sprintf(format string, args ...any) string {
	var b strings.Builder
	Fprintf(&b, format, args...)
	return b.String()
}

// Appendf is a drop-in replacement for strconv.Appendf that formats []byte and string as sql-quoted strings when needed.
func Appendf(b []byte, format string, args ...any) []byte {
	for i := range args {
		args[i] = sqlquoter{args[i]}
	}
	return fmt.Appendf(b, format, args...)
}

// Sprint is a drop-in replacement for fmt.Sprint that formats []byte and string as sql-quoted strings when needed.
func Sprint(args ...any) string {
	var b strings.Builder
	Fprint(&b, args...)
	return b.String()
}

// Format implements fmt.Formatter. This
//
//   - nil as the literal string "NULL"
//
//   - int and uint are formatted as decimal numbers (as with %d)
//
//   - float is formatted as a floating-point number (as with %g)
//
//   - time.Time is formatted as an RFC3339 string in UTC
//
//   - formats bools as TRUE or FALSE
//
//   - formats []byte and string as sql-quoted strings (see the package documentation for details)
//
//   - all other types are formatted as "/*<bad type %T>*/"
func (qf sqlquoter) Format(f fmt.State, c rune) {
	var s string
	switch v := qf.Val.(type) {
	case nil:
		f.Write([]byte("NULL"))
		return
	case int8, int16, int32, int64, int, uint8, uint16, uint32, uint64, uint, uintptr:
		fmt.Fprintf(f, fmt.FormatString(f, 'd'), v)
		return
	case float32, float64:
		fmt.Fprintf(f, fmt.FormatString(f, 'g'), v)
	case bool:
		if v {
			f.Write([]byte("TRUE"))
		} else {
			f.Write([]byte("FALSE"))
		}
		return
	case []byte:
		s = string(v)
	case string:
		s = v
	case time.Time:
		s = v.UTC().Format(time.RFC3339)
	default:
		fmt.Fprintf(f, "/*<bad type %T>*/", v)
		return
	}
	// place 64 bytes on the stack to avoid extra allocations
	// in the common case of small, simple strings.
	var scratch [64]byte
	f.Write(QuoteIfNeeded(scratch[:0], s))
}
